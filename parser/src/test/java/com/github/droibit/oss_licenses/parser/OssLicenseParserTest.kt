package com.github.droibit.oss_licenses.parser

import android.content.Context
import android.content.res.Resources
import androidx.core.content.res.ResourcesCompat.ID_NULL
import com.google.common.truth.Truth.assertThat
import io.mockk.every
import io.mockk.impl.annotations.MockK
import io.mockk.junit4.MockKRule
import io.mockk.mockk
import io.mockk.mockkStatic
import kotlin.coroutines.cancellation.CancellationException
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestDispatcher
import kotlinx.coroutines.test.runTest
import okio.BufferedSource
import okio.ByteString
import okio.Source
import okio.buffer
import okio.source
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test

class OssLicenseParserTest {
  @get:Rule
  val mockkRule = MockKRule(this)

  @MockK
  private lateinit var context: Context
  private lateinit var testDispatcher: TestDispatcher
  private lateinit var parser: OssLicenseParser

  @Before
  fun setUp() {
    testDispatcher = StandardTestDispatcher()
    parser = OssLicenseParser(testDispatcher)
  }

  @Test
  fun parse_licensesNotFound() = runTest(testDispatcher) {
    val appContext = mockk<Context> {
      every { resources } returns mockk<Resources> {
        every { getIdentifier(eq("third_party_licenses"), any(), any()) } returns ID_NULL
        every { getIdentifier(eq("third_party_license_metadata"), any(), any()) } returns 1
      }
      every { packageName } returns "package"
    }
    every { context.applicationContext } returns appContext

    try {
      parser.parse(context)
      fail("error.")
    } catch (e: Exception) {
      assertThat(e).isInstanceOf(IllegalStateException::class.java)
      assertThat(e).hasMessageThat()
        .isEqualTo("Third party library license resources generated by OSS Licenses Gradle Plugin dose not exist.")
    }
  }

  @Test
  fun parse_licenseMetadataNotFound() = runTest(testDispatcher) {
    val appContext = mockk<Context> {
      every { resources } returns mockk<Resources> {
        every { getIdentifier(eq("third_party_licenses"), any(), any()) } returns 1
        every { getIdentifier(eq("third_party_license_metadata"), any(), any()) } returns ID_NULL
      }
      every { packageName } returns "package"
    }
    every { context.applicationContext } returns appContext

    try {
      parser.parse(context)
      fail("error.")
    } catch (e: Exception) {
      assertThat(e).isInstanceOf(IllegalStateException::class.java)
      assertThat(e).hasMessageThat()
        .isEqualTo("Third party library license resources generated by OSS Licenses Gradle Plugin dose not exist.")
    }
  }

  @Test
  fun parse_withRealData() = runTest(testDispatcher) {
    val licenseMetadata = """
    0:46 Compose Animation Core
    0:46 Compose Tooling Data
    0:46 Compose Util
    0:46 Compose UI
    0:46 Android Lifecycle Kotlin Extensions
    47:47 JetBrains Java Annotations
    47:47 kotlinx-coroutines-android
    47:47 Dagger
    47:47 kotlinx-coroutines-core
    47:47 kotlinx-coroutines-bom
    """.trimIndent()
    val licenses = """
    http://www.apache.org/licenses/LICENSE-2.0.txt
    https://www.apache.org/licenses/LICENSE-2.0.txt
    """.trimIndent()
    val licenseMetadataSource = licenseMetadata.byteInputStream().source()
    val licensesSource = licenses.byteInputStream().source()

    val result = parser.parse(licensesSource, licenseMetadataSource, emptySet())
    assertThat(result).containsExactly(
      OssLicense(
        "Android Lifecycle Kotlin Extensions",
        "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense("Compose Animation Core", "http://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("Compose Tooling Data", "http://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("Compose UI", "http://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("Compose Util", "http://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("Dagger", "https://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("JetBrains Java Annotations", "https://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("kotlinx-coroutines-android", "https://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("kotlinx-coroutines-bom", "https://www.apache.org/licenses/LICENSE-2.0.txt"),
      OssLicense("kotlinx-coroutines-core", "https://www.apache.org/licenses/LICENSE-2.0.txt"),
    ).inOrder()
  }

  @Test
  fun parse_withIgnoreLibraries() = runTest(testDispatcher) {
    val licenseMetadata = "0:8 library1\n9:8 library2"
    val licenses = "license1\nlicense2"
    val licenseMetadataSource = licenseMetadata.byteInputStream().source()
    val licensesSource = licenses.byteInputStream().source()

    val result = parser.parse(licensesSource, licenseMetadataSource, setOf("library1"))
    assertThat(result).containsExactly(
      OssLicense("library2", "license2"),
    )
  }

  @Test
  fun parse_withEmptyResources() = runTest(testDispatcher) {
    val emptySource = "".byteInputStream().source()

    val result = parser.parse(emptySource, emptySource)
    assertThat(result).isEmpty()
  }

  @Test
  fun parse_checkCancellation() = runTest(testDispatcher) {
    var job: Job? = null
    job = launch {
      mockkStatic("okio.Okio")
      val bufferedLicenseMetadataSource = mockk<BufferedSource>(relaxed = true) {
        var callCount = 0
        every { readUtf8Line() } answers {
          callCount++
          return@answers when (callCount) {
            1 -> "1:2 library1"
            2 -> "3:4 library2".also { job?.cancel() }
            3 -> "5:6 library3"
            else -> null
          }
        }
      }
      val licenseMetadataSource = mockk<Source> {
        every { buffer() } returns bufferedLicenseMetadataSource
      }

      val bufferedLicensesSource = mockk<BufferedSource>(relaxed = true) {
        every { readByteString() } returns mockk<ByteString> {
          val licenses = "abcdefghijklmn".toByteArray()
          every { substring(any(), any()) } returns ByteString.of(*licenses)
        }
      }
      val licensesSource = mockk<Source> {
        every { buffer() } returns bufferedLicensesSource
      }

      try {
        parser.parse(licensesSource, licenseMetadataSource)
        fail("error.")
      } catch (e: Exception) {
        assertThat(e).isInstanceOf(CancellationException::class.java)
      }
    }
  }
}
