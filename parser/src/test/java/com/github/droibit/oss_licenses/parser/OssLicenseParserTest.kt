package com.github.droibit.oss_licenses.parser

import android.content.Context
import android.content.res.Resources
import androidx.core.content.res.ResourcesCompat.ID_NULL
import com.google.common.truth.Truth.assertThat
import io.mockk.every
import io.mockk.mockk
import io.mockk.mockkStatic
import kotlin.coroutines.cancellation.CancellationException
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestDispatcher
import kotlinx.coroutines.test.runTest
import okio.BufferedSource
import okio.ByteString
import okio.Source
import okio.buffer
import okio.source
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test

private const val RES_LICENSES_METADATA = "third_party_license_metadata"
private const val RES_LICENSES = "third_party_licenses"

class OssLicenseParserTest {
  private lateinit var testDispatcher: TestDispatcher
  private lateinit var parser: OssLicenseParser

  @Before
  fun setUp() {
    testDispatcher = StandardTestDispatcher()
    parser = OssLicenseParser(testDispatcher)
  }

  @Test
  fun parse_licensesNotFound() = runTest(testDispatcher) {
    val context = mockk<Context> {
      every { applicationContext } returns mockk<Context> {
        every { resources } returns mockk<Resources> {
          every { getIdentifier(eq("third_party_licenses"), any(), any()) } returns ID_NULL
          every { getIdentifier(eq(RES_LICENSES_METADATA), any(), any()) } returns 1
        }
        every { packageName } returns "package"
      }
    }

    try {
      parser.parse(context)
      fail("error.")
    } catch (e: Exception) {
      assertThat(e).isInstanceOf(IllegalStateException::class.java)
      assertThat(e).hasMessageThat()
        .isEqualTo("Third party library license resources generated by OSS Licenses Gradle Plugin dose not exist.")
    }
  }

  @Test
  fun parse_licenseMetadataNotFound() = runTest(testDispatcher) {
    val context = mockk<Context> {
      every { applicationContext } returns mockk<Context> {
        every { resources } returns mockk<Resources> {
          every { getIdentifier(eq(RES_LICENSES), any(), any()) } returns 1
          every { getIdentifier(eq(RES_LICENSES_METADATA), any(), any()) } returns ID_NULL
        }
        every { packageName } returns "package"
      }
    }

    try {
      parser.parse(context)
      fail("error.")
    } catch (e: Exception) {
      assertThat(e).isInstanceOf(IllegalStateException::class.java)
      assertThat(e).hasMessageThat()
        .isEqualTo("Third party library license resources generated by OSS Licenses Gradle Plugin dose not exist.")
    }
  }

  @Test
  fun parseInternal_withRealData() = runTest(testDispatcher) {
    val licenseMetadata = """
    0:46 Compose Animation Core
    0:46 Compose Tooling Data
    0:46 Compose Util
    0:46 Compose UI
    0:46 Android Lifecycle Kotlin Extensions
    47:47 JetBrains Java Annotations
    47:47 kotlinx-coroutines-android
    47:47 Dagger
    47:47 kotlinx-coroutines-core
    47:47 kotlinx-coroutines-bom
    """.trimIndent()
    val licenseMetadataSource = licenseMetadata.byteInputStream().source()

    val licenses = """
    http://www.apache.org/licenses/LICENSE-2.0.txt
    https://www.apache.org/licenses/LICENSE-2.0.txt
    """.trimIndent()
    val licensesSource = licenses.byteInputStream().source()

    val result = parser.parseInternal(licensesSource, licenseMetadataSource)
    assertThat(result).containsExactly(
      OssLicense(
        library = "Android Lifecycle Kotlin Extensions",
        text = "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "Compose Animation Core",
        text = "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "Compose Tooling Data",
        text = "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "Compose UI",
        text = "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "Compose Util",
        text = "http://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "Dagger",
        text = "https://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "JetBrains Java Annotations",
        text = "https://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "kotlinx-coroutines-android",
        text = "https://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "kotlinx-coroutines-bom",
        text = "https://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
      OssLicense(
        library = "kotlinx-coroutines-core",
        text = "https://www.apache.org/licenses/LICENSE-2.0.txt",
      ),
    ).inOrder()
  }

  @Test
  fun parseInternal_withIgnoreLibraries() = runTest(testDispatcher) {
    val licenseMetadata = """
      0:8 library1
      9:8 library2
    """.trimIndent()
    val licenses = """
      license1
      license2
    """.trimIndent()
    val licenseMetadataSource = licenseMetadata.byteInputStream().source()
    val licensesSource = licenses.byteInputStream().source()

    val result = parser.parseInternal(licensesSource, licenseMetadataSource, setOf("library1"))
    assertThat(result).containsExactly(
      OssLicense("library2", "license2"),
    )
  }

  @Test
  fun parseInternal_withEmptyResources() = runTest(testDispatcher) {
    val emptySource = "".byteInputStream().source()
    val result = parser.parseInternal(emptySource, emptySource)
    assertThat(result).isEmpty()
  }

  @Test
  fun parseInternal_checkCancellation() = runTest(testDispatcher) {
    var job: Job? = null
    job = launch {
      mockkStatic("okio.Okio")
      val bufferedLicenseMetadataSource = mockk<BufferedSource>(relaxed = true) {
        var callCount = 0
        every { readUtf8Line() } answers {
          callCount++
          return@answers when (callCount) {
            1 -> "1:2 library1"
            2 -> "3:4 library2".also { job?.cancel() }
            3 -> "5:6 library3"
            else -> null
          }
        }
      }
      val licenseMetadataSource = mockk<Source> {
        every { buffer() } returns bufferedLicenseMetadataSource
      }

      val bufferedLicensesSource = mockk<BufferedSource>(relaxed = true) {
        every { readByteString() } returns mockk<ByteString> {
          val licenses = "abcdefghijklmn".toByteArray()
          every { substring(any(), any()) } returns ByteString.of(*licenses)
        }
      }
      val licensesSource = mockk<Source> {
        every { buffer() } returns bufferedLicensesSource
      }

      try {
        parser.parseInternal(licensesSource, licenseMetadataSource)
        fail("error.")
      } catch (e: Exception) {
        assertThat(e).isInstanceOf(CancellationException::class.java)
      }
    }
  }
}
